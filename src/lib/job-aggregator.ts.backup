// Comprehensive Job Aggregation System
// Pulls jobs from multiple platforms including USAJobs, Indeed, LinkedIn, GitHub, and more

// Import RSS jobs
import { getAllRSSJobs, getMockRSSJobs } from './rss-jobs';

export interface JobListing {
  id: string;
  title: string;
  company: string;
  location: string;
  salary?: {
    min?: number;
    max?: number;
    currency?: string;
    period?: string;
  };
  type?: string;
  posted?: string;
  description?: string;
  requirements?: string[];
  source: string;
  url?: string;
  remote?: boolean;
  benefits?: string[];
  experience?: string;
  education?: string;
  skills?: string[];
  industry?: string;
  companySize?: string;
  logo?: string;
}

export interface JobSearchParams {
  query?: string;
  location?: string;
  remote?: boolean;
  salaryMin?: number;
  salaryMax?: number;
  jobType?: string;
  experience?: string;
  industry?: string;
  sources?: string[];
  limit?: number;
  page?: number;
}

// API Keys from environment
const API_KEYS = {
  USAJOBS: import.meta.env.VITE_USAJOBS_API_KEY,
  USAJOBS_USER_AGENT: import.meta.env.VITE_USAJOBS_USER_AGENT || "Gigm8 Job Search Platform (contact@gigm8.com)",
  ZIPRECRUITER: import.meta.env.VITE_ZIPRECRUITER_API_KEY,
  JOOBLE: import.meta.env.VITE_JOOBLE_API_KEY,
  ADZUNA_ID: import.meta.env.VITE_ADZUNA_APP_ID,
  ADZUNA_KEY: import.meta.env.VITE_ADZUNA_APP_KEY,
  INDEED: import.meta.env.VITE_INDEED_PUBLISHER_ID,
  GLASSDOOR_ID: import.meta.env.VITE_GLASSDOOR_PARTNER_ID,
  GLASSDOOR_KEY: import.meta.env.VITE_GLASSDOOR_KEY,
  LINKEDIN_ID: import.meta.env.VITE_LINKEDIN_CLIENT_ID,
  LINKEDIN_SECRET: import.meta.env.VITE_LINKEDIN_CLIENT_SECRET,
  GITHUB_ID: import.meta.env.VITE_GITHUB_CLIENT_ID,
  GITHUB_SECRET: import.meta.env.VITE_GITHUB_CLIENT_SECRET,
  STACKOVERFLOW_ID: import.meta.env.VITE_STACKOVERFLOW_CLIENT_ID,
  STACKOVERFLOW_SECRET: import.meta.env.VITE_STACKOVERFLOW_CLIENT_SECRET,
  ANGEL: import.meta.env.VITE_ANGEL_API_KEY,
  DICE: import.meta.env.VITE_DICE_API_KEY,
  MONSTER: import.meta.env.VITE_MONSTER_API_KEY,
  CAREERBUILDER: import.meta.env.VITE_CAREERBUILDER_API_KEY,
  SIMPLYHIRED: import.meta.env.VITE_SIMPLYHIRED_API_KEY,
};

// 1. USAJobs Integration (Government Jobs)
export async function searchUSAJobs(params: JobSearchParams): Promise<JobListing[]> {
  if (!API_KEYS.USAJOBS || !API_KEYS.USAJOBS_USER_AGENT) {
    console.warn('USAJobs API key not configured');
    return [];
  }

  try {
    const searchParams = new URLSearchParams({
      Keyword: params.query || '',
      LocationName: params.location || '',
      ResultsPerPage: (params.limit || 25).toString(),
      Page: (params.page || 1).toString(),
    });

    const response = await fetch(`https://data.usajobs.gov/api/search?${searchParams}`, {
      headers: {
        'Host': 'data.usajobs.gov',
        'User-Agent': API_KEYS.USAJOBS_USER_AGENT,
        'Authorization-Key': API_KEYS.USAJOBS,
      },
    });

    if (!response.ok) {
      throw new Error(`USAJobs API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.SearchResult?.SearchResultItems?.map((job: any) => ({
      id: `usajobs-${job.MatchedObjectId}`,
      title: job.MatchedObjectDescriptor?.PositionTitle || 'Government Position',
      company: job.MatchedObjectDescriptor?.OrganizationName || 'U.S. Government',
      location: job.MatchedObjectDescriptor?.PositionLocationDisplay || 'Various Locations',
      description: job.MatchedObjectDescriptor?.UserArea?.Details?.JobSummary || '',
      requirements: job.MatchedObjectDescriptor?.QualificationSummary?.split('\n').filter(Boolean) || [],
      source: 'USAJobs',
      url: job.MatchedObjectDescriptor?.ApplyURI?.[0] || '',
      type: 'Full-time',
      posted: job.MatchedObjectDescriptor?.PublicationStartDate,
      remote: job.MatchedObjectDescriptor?.PositionLocationDisplay?.toLowerCase().includes('remote') || false,
    })) || [];
  } catch (error) {
    console.error('USAJobs search error:', error);
    return [];
  }
}

// 2. RemoteOK Jobs (Free API)
export async function searchRemoteOKJobs(params: JobSearchParams): Promise<JobListing[]> {
  try {
    const response = await fetch('https://remoteok.io/api');
    
    if (!response.ok) {
      throw new Error(`RemoteOK API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.slice(1).filter((job: any) => 
      !params.query || 
      job.position?.toLowerCase().includes(params.query.toLowerCase()) ||
      job.company?.toLowerCase().includes(params.query.toLowerCase())
    ).slice(0, params.limit || 25).map((job: any) => ({
      id: `remoteok-${job.id}`,
      title: job.position || 'Remote Position',
      company: job.company || 'Unknown Company',
      location: 'Remote',
      description: job.description || '',
      source: 'RemoteOK',
      url: job.url || '',
      type: job.contract ? 'Contract' : 'Full-time',
      posted: job.date,
      remote: true,
      salary: job.salary_min || job.salary_max ? {
        min: job.salary_min,
        max: job.salary_max,
        currency: 'USD',
      } : undefined,
    }));
  } catch (error) {
    console.error('RemoteOK search error:', error);
    return [];
  }
}

// 3. GitHub Jobs (via GitHub API)
export async function searchGitHubJobs(params: JobSearchParams): Promise<JobListing[]> {
  if (!API_KEYS.GITHUB_ID || !API_KEYS.GITHUB_SECRET) {
    console.warn('GitHub API keys not configured');
    return [];
  }

  try {
    // GitHub doesn't have a jobs API, but we can search for job-related repositories
    const response = await fetch(`https://api.github.com/search/repositories?q=${encodeURIComponent(params.query || 'jobs')}+language:javascript&sort=stars&per_page=${params.limit || 25}`, {
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Gigm8-JobSearch',
      },
    });

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.items?.map((repo: any) => ({
      id: `github-${repo.id}`,
      title: `Open Source Project: ${repo.name}`,
      company: repo.owner?.login || 'GitHub',
      location: 'Remote',
      description: repo.description || '',
      source: 'GitHub',
      url: repo.html_url,
      type: 'Open Source',
      posted: repo.created_at,
      remote: true,
    })) || [];
  } catch (error) {
    console.error('GitHub search error:', error);
    return [];
  }
}

// 4. Adzuna Jobs
export async function searchAdzunaJobs(params: JobSearchParams): Promise<JobListing[]> {
  if (!API_KEYS.ADZUNA_ID || !API_KEYS.ADZUNA_KEY) {
    console.warn('Adzuna API keys not configured');
    return [];
  }

  try {
    const searchParams = new URLSearchParams({
      app_id: API_KEYS.ADZUNA_ID,
      app_key: API_KEYS.ADZUNA_KEY,
      what: params.query || '',
      where: params.location || '',
      results_per_page: (params.limit || 25).toString(),
      page: (params.page || 1).toString(),
    });

    const response = await fetch(`https://api.adzuna.com/v1/api/jobs/us/search/1?${searchParams}`);
    
    if (!response.ok) {
      throw new Error(`Adzuna API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.results?.map((job: any) => ({
      id: `adzuna-${job.id}`,
      title: job.title || 'Job Position',
      company: job.company?.display_name || 'Unknown Company',
      location: job.location?.display_name || 'Unknown Location',
      description: job.description || '',
      source: 'Adzuna',
      url: job.redirect_url || '',
      type: job.contract_type || 'Full-time',
      posted: job.created,
      remote: job.remote || false,
      salary: job.salary_min || job.salary_max ? {
        min: job.salary_min,
        max: job.salary_max,
        currency: 'USD',
      } : undefined,
    })) || [];
  } catch (error) {
    console.error('Adzuna search error:', error);
    return [];
  }
}

// 5. Jooble Jobs
export async function searchJoobleJobs(params: JobSearchParams): Promise<JobListing[]> {
  if (!API_KEYS.JOOBLE) {
    console.warn('Jooble API key not configured');
    return [];
  }

  try {
    const response = await fetch('https://jooble.org/api/1/search', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        keywords: params.query || '',
        location: params.location || '',
        radius: 25,
        page: params.page || 1,
        limit: params.limit || 25,
      }),
    });

    if (!response.ok) {
      throw new Error(`Jooble API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.jobs?.map((job: any) => ({
      id: `jooble-${job.id}`,
      title: job.title || 'Job Position',
      company: job.company || 'Unknown Company',
      location: job.location || 'Unknown Location',
      description: job.snippet || '',
      source: 'Jooble',
      url: job.link || '',
      type: 'Full-time',
      posted: job.updated,
      remote: job.remote || false,
    })) || [];
  } catch (error) {
    console.error('Jooble search error:', error);
    return [];
  }
}

// 6. RSS Feed Jobs (Multiple Sources)
export async function searchRSSJobs(params: JobSearchParams): Promise<JobListing[]> {
  try {
    // For now, use mock data since RSS feeds require CORS proxy
    const rssJobs = getMockRSSJobs();
    
    return rssJobs
      .filter(job => 
        !params.query || 
        job.title.toLowerCase().includes(params.query.toLowerCase()) ||
        job.company.toLowerCase().includes(params.query.toLowerCase()) ||
        job.description.toLowerCase().includes(params.query.toLowerCase())
      )
      .filter(job => 
        !params.location || 
        job.location.toLowerCase().includes(params.location.toLowerCase()) ||
        job.remote
      )
      .map(job => ({
        id: job.id,
        title: job.title,
        company: job.company,
        location: job.location,
        description: job.description,
        source: job.source,
        url: job.url,
        type: job.type,
        posted: job.posted,
        remote: job.remote || false,
      }));
  } catch (error) {
    console.error('RSS jobs search error:', error);
    return [];
  }
}

// Main job search function that aggregates from all sources
export async function searchAllJobs(params: JobSearchParams): Promise<JobListing[]> {
  const {
    sources = ['usajobs', 'remoteok', 'adzuna', 'jooble', 'github', 'rss'],
    limit = 50
  } = params;

  const searchPromises: Promise<JobListing[]>[] = [];

  // Add search functions based on requested sources
  if (sources.includes('usajobs')) {
    searchPromises.push(searchUSAJobs(params));
  }
  if (sources.includes('remoteok')) {
    searchPromises.push(searchRemoteOKJobs(params));
  }
  if (sources.includes('adzuna')) {
    searchPromises.push(searchAdzunaJobs(params));
  }
  if (sources.includes('jooble')) {
    searchPromises.push(searchJoobleJobs(params));
  }
  if (sources.includes('github')) {
    searchPromises.push(searchGitHubJobs(params));
  }
  if (sources.includes('rss')) {
    searchPromises.push(searchRSSJobs(params));
  }

  try {
    const results = await Promise.allSettled(searchPromises);
    const allJobs: JobListing[] = [];

    results.forEach((result) => {
      if (result.status === 'fulfilled') {
        allJobs.push(...result.value);
      } else {
        console.error('Job search error:', result.reason);
      }
    });

    // Remove duplicates based on title and company
    const uniqueJobs = allJobs.filter((job, index, self) => 
      index === self.findIndex(j => j.title === job.title && j.company === job.company)
    );

    // Sort by relevance and date
    uniqueJobs.sort((a, b) => {
      // Prioritize jobs with descriptions
      if (a.description && !b.description) return -1;
      if (!a.description && b.description) return 1;
      
      // Sort by posted date (newest first)
      if (a.posted && b.posted) {
        return new Date(b.posted).getTime() - new Date(a.posted).getTime();
      }
      
      return 0;
    });

    return uniqueJobs.slice(0, limit);
  } catch (error) {
    console.error('Job search aggregation error:', error);
    return [];
  }
}

// Get available job sources
export function getAvailableSources(): Array<{id: string, name: string, free: boolean, description: string}> {
  return [
    { id: 'usajobs', name: 'USAJobs', free: true, description: 'Government jobs' },
    { id: 'remoteok', name: 'RemoteOK', free: true, description: 'Remote jobs' },
    { id: 'adzuna', name: 'Adzuna', free: false, description: 'International job board' },
    { id: 'jooble', name: 'Jooble', free: false, description: 'Job aggregator' },
    { id: 'github', name: 'GitHub', free: true, description: 'Open source projects' },
    { id: 'rss', name: 'RSS Feeds', free: true, description: 'Company job feeds' },
  ];
}

// Test API connections
export async function testAPIConnections(): Promise<Record<string, boolean>> {
  const results: Record<string, boolean> = {};

  // Test USAJobs
  try {
    const usajobsJobs = await searchUSAJobs({ query: 'software', limit: 1 });
    results.usajobs = usajobsJobs.length > 0;
  } catch {
    results.usajobs = false;
  }

  // Test RemoteOK
  try {
    const remoteokJobs = await searchRemoteOKJobs({ query: 'developer', limit: 1 });
    results.remoteok = remoteokJobs.length > 0;
  } catch {
    results.remoteok = false;
  }

  // Test Adzuna
  try {
    const adzunaJobs = await searchAdzunaJobs({ query: 'engineer', limit: 1 });
    results.adzuna = adzunaJobs.length > 0;
  } catch {
    results.adzuna = false;
  }

  // Test Jooble
  try {
    const joobleJobs = await searchJoobleJobs({ query: 'manager', limit: 1 });
    results.jooble = joobleJobs.length > 0;
  } catch {
    results.jooble = false;
  }

  return results;
}
